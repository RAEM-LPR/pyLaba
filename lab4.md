# NumPy

**NumPy** - Библиотека для работы с многомерными массивами, например векторами и матрицами.

## Создание массивов

Самый простой вариант - из привычных списков


```python
import numpy as np

a = np.array([1, 2, 3])
print(a)
print(type(a), type([1, 2, 3]))
```

Создадим теперь двумерный массив - матрицу:


```python
a = np.array([[1, 2], [3, 4]])
print(a)
```

Для удобства, можно использовать вот такую функцию для красивого отображения матриц в Jupyter:


```python
import IPython.display

def show(mat):
    tex = r'\begin{pmatrix}' + r'\\'.join('&'.join(map(str, row)) for row in mat) + r'\end{pmatrix}'
    IPython.display.display(IPython.display.Math(tex))

show(a)
```

Еще несколько способов создания стандартных массивов:


```python
np.repeat(15, 5) # Массив полученные повторением исходного объекта
```


```python
show(np.zeros((3, 3))) # Массив из нулей
```


```python
show(np.ones((3, 1))) # Массив из единиц
```


```python
show(np.eye(3)) # Единичная матрица
```

В отличае от списков (`list`), массивы **NumPy** всегда состоят из однотипных элементов.
При создании массивов можно явно указать тип эелементов. При этом в **NumPy** свои типы, например `numpy.int32`, `numpy.int64`, `numpy.float64`. Впрочем, можно указывать и стандартные типы, которые будут отображены в `numpy` типы. Например:


```python
a = np.eye(3, dtype=int)
print(a.dtype)
print(type(a[0][0]))
show(a)
```


```python
np.array([1, 2, 5], np.float64)
```

Или даже


```python
np.array(input().split(), float)
```

## Операции над массивами

В **NumPy** нам доступны все стандартные математические операции над массивами - от суммы векторов до произведения матриц.

Умножение на число:


```python
a = np.array([1, 2, 3])
a * 2
```

Сравните с тем, как работает эта операция со стандартными списками:


```python
[1, 2, 3] * 2
```

Аналогично работает и деление на число, а также и остальные арифметические операции массива с числом - поэлементно.
Также естественно работает сложение векторов:


```python
np.array([1, 2, 3]) + np.array([3, 2, 1])
```

Однако, умножение оператором `*` не является ни скалярным, ни векторным произведением. Напротив, `*` работает также как и `+` и все остальные арифметичекие операторы - поэлементно:


```python
np.array([1, 2, 3]) * np.array([2, 2, 1])
```

Для вычисления скалярного произведения есть метод `.dot()` у массивов, например `a.dot(b)`. Векторное произведенией записывается как `np.cross(a, b)`, а длину вектора можно вычислить как `np.linalg.norm(a)`.
Итак, теперь вы во всеоружии, пришло время размяться:

### Упражнение 1

На плоскости расположено несколько маленьких шариков разных масс. Пользователь задает их координаты (на плоскости) и массы. Выведите координты центра масс всей системы. Формат ввода организуйте на свой вкус.


```python

```

### Упражнение 2

Свет падает на плоскость в направлении заданным вектором L (в 3-мерном пространстве). Сама плоскость задана тремя точками A, B и C, через которые она проходит. Найдите вектор отраженного света. Пользователь вводит L, A, B и C, в виде троек чисел - координат через пробел, каждый вектор в новой строке.


```python

```

Также, **NumPy** предоставляет нам привычные оперции над матрицами:
- `np.linalg.det(a)` - определитель матрицы `a`
- `a.T` - транспонированная матрица
- `np.matmul(a, b)` - произведение матриц


```python
a = np.array([[1, 2], [3, 4]])
show(a)
b = a.T
show(b)
b[1][0] = 10
show(b)
show(a)
```

Обратите внимание, при изменении элемента `b`, матрица `a` тоже изменилась. Это потому, что `a.T` не создает новой матрицы, а лишь предоставляет доступ к имеющимся данным "по-другому".

### Упражнение 3

Пользователь вводит две квадратные матрицы 3x3. Посчитайте их произведение без использования numpy. Затем с помощью `np.matmul()`. Выведите оба результата.


```python

```

# Matplotlib

Построение графика по точкам:


```python
import matplotlib.pyplot as plt
plt.plot([1, 2, 3, 4, 5], [3, 2, 3, 4, 4])
plt.show()
```

Что ж, построим что-нибудь поинтереснее. Для этого нам понадобятся две новые фишки `numpy`:
`np.linspace(a, b, n)` - создает возрастающий массив чисел от `a` до `b` через равные промежутки из `n` элементов - то что нам нужно для оси X.
`np.vectorize(f)` - создает новую функцию, которая умеет преобразовывать вектор целиком, применяя к каждому элементу функцию `f`.


```python
import math
x = np.linspace(-5, 5, 100)
y = np.vectorize(math.sin)(x)

# Заодно, добавим некоторые дополнительные элементы:
plt.title('График функции y = sin(x)')  # заголовок
plt.xlabel('x')  # ось абсцисс
plt.ylabel('y')  # ось ординат
plt.grid() # включение отображение сетки
plt.axis('equal') # выровнять масштаб по осям (попробуйте закомментировать)

plt.plot(x, y)
plt.show()
```

### Упражнение 4

С помощью matplotlib нарисуйте график функции $y(x) = 10x^3 + 2x^2 - x$


```python

```

### Упражнение 5
С помощью matplotlib нарисуйте спираль


```python


```

### Точечная диаграмма
Познакомимся с двумя новыми функциями:

`numpy.random.rand(n)` - случайный вектор из `n` элементов

`matplotlib.pyplot.scatter(x, y, ...)` - рисуем точки, точнее круги. Некоторые аргументы:

   - `x` - массив x-координат
   - `y` - массив y-координат
   - `s` - массив площадей кругов
   - `c` - массив цветов
   - `alpha` - степень прозрачности кругов


```python
n = 50
x = np.random.rand(n)
y = np.random.rand(n)
colors = np.random.rand(n)
sq = (30 * np.random.rand(n)) ** 2

plt.scatter(x, y, s=sq, c=colors, alpha=0.5)
plt.show()
```

### Упражнение 6
В Python можно легко работать с комплексными числами. Например, число $1+2i$ записывается как `1 + 2j`, или `complex(1, 2)`. Действительную часть комплексного числа можно получить как `x.real`, а комплексную - `x.imag`. Постройте на плоскости последовательность точек, заданную рекурсивной формулой $z_{n+1} = z_n^2 + c$ где $c$ - некоторая комплексная константа (пусть ее задает пользователь) а $z_0 = 0$. Точки плоскости $c$, для которых данная последовательность ограничена, образуют известный фрактал - [множество Мандельброта](https://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%D0%9C%D0%B0%D0%BD%D0%B4%D0%B5%D0%BB%D1%8C%D0%B1%D1%80%D0%BE%D1%82%D0%B0).


```python

```
