# Введение.

Данный курс будет посвящен изучению программирования с использованием языка **Python**. Python — это современный язык
программирования, работающий на всех распространённых операционных системах.

В настоящее время существуют две версии языка Python: версия 2 и более современная версия 3. Они не вполне совместимы друг с другом: программа, написанная для одной версии языка может
оказаться невыполнимой для другой версии. Но в основном обе версии очень похожи.

О различиях Python2 и Python3 вы можете прочитать [тут][1].

[1]: https://pythonworld.ru/osnovy/python2-vs-python3-razlichiya-sintaksisa.html

Мы будем использовать версию 3 данного языка, некоторые из используемых примеров не будут работать с версией 2.
Последняя версия языка, доступная в сентябре 2022 года — 3.10.6, именно её необходимо установить дома, скачав данную
версию с сайта www.python.org

Запустить интерпретатор python можно из командной строки:
``` bash
python3
```

Будьте внимательны — команда `python` запустит интерпретатор версии 2, с которым мы работать не будем. В системе
Windows можно использовать пункт меню «Python (command line)».

# IPython – расширенная оболочка

IPython – интерактивная оболочка для языка программирования Python, которая предоставляет расширенную интроспекцию,
дополнительный командный синтаксис, подсветку кода и автоматическое дополнение. В настоящее время IPython вошел в
состав ядра системы для анализа данных и обработки научной информации [Jupyter].

[Jupyter]: http://jupyter.org

IPython может использоваться как замена стандартной командной оболочки операционной системы, особенно на платформе
Windows, возможности оболочки которой ограничены. Поведение по умолчанию похоже на поведение оболочек UNIX-подобных
систем, но тот факт, что работа происходит в окружении Python, позволяет добиваться большей настраиваемости и
гибкости.

Для обучения возможностям Python лучше сразу использовать оболочку IPython.
Для этого необходимо установить [Jupyter].

[Jupyter]: http://jupyter.org

Итак, запустив оболочку IPython, Вы увидите примерно следующее приглашение командной строки:

``` pycon

   Python 3.1.2 (r312:79147, Jun 12 2010, 15:29:06)
   [GCC 4.4.3 20100316 (ALT Linux 4.4.3-alt2)] on linux2
   Type "help", "copyright", "credits" or "license" for more information.
   >>>
```

Смело вводите команды и наслаждайтесь результатом. А что можно вводить? Несколько примеров:

``` pycon

   >>> 2 + 2
   4
   >>> 2 ** 100
   1267650600228229401496703205376
   >>> 'Hello' + 'World'
   'HelloWorld'
   >>> 'ABC' * 10
   'ABCABCABCABCABCABCABCABCABCABC'
```

Первая команда вычисляет сумму двух чисел, вторая команда вычисляет 2 в степени 100, третья команда выполняет операцию
**конкатенации** для строк, а четвертая команда печатает строку `'ABC'`, повторенную 10 раз.

Хотите закончить работу с питоном? Введите команду `exit()` (именно так, со скобочками, так как это — **функция**)
или нажмите ``Ctrl+D``.

# Типы данных

Итак, мы видим, что Python умеет работать как минимум с двумя видами данных — числами и строками. Числа записываются
последовательностью цифр, также перед числом может стоять знак минус, а строки записываются в кавычках. `2`
и `'2'` — это разные объекты, первый объект — число, а второй — строка. Операция ``+`` для целых чисел и для строк
работает по-разному: для чисел это сложение, а для строк — конкатенация.

Кроме целых чисел есть и другой класс чисел: действительные (вещественные числа), представляемые в виде десятичных
дробей. Они записываются с использованием десятичной точки, например, `2.0`. В каком-то смысле, `2` и `2.0`
имеют равные значение, но это — разные объекты. Например, можно вычислить значения выражения `'ABC' * 10` (повторить
строку 10 раз), но нельзя вычислить `'ABC' * 10.0`.

Определить тип объекта можно при помощи функции `type`:

``` pycon

   >>> type(2)
   <class 'int'>
   >>> type('2')
   <class 'str'>
   >>> type(2.0)
   <class 'float'>
```

Обратите внимание — `type` является функцией, аргументы функции указываются в скобках после ее имени.

Вот список основных операций для чисел:

- `A+B` — сумма;
- `A-B` — разность;
- `A*B` — произведение;
- `A/B` — частное;
- `A**B` — возведение в степень.

Полезно помнить, что квадратный корень из числа ``x`` — это `x**0.5`, а корень степени ``n`` — это `x**(1/n)`.

Есть также унарный вариант операции ``-``, то есть операция с одним аргументом. Она возвращает число, противоположное
данному. Например: `-A`.

В выражении может встречаться много операций подряд. Как в этом случае определяется порядок действий? Например, чему
будет равно `1+2*3**1+1`? В данном случае ответ будет 8, так как сначала выполняется возведение в степень, затем —
умножение, затем —  сложение.

Более общие правила определения приоритетов операций такие:

1. Выполняются возведения в степень  **справа налево**, то есть `3**3**3` это 3²⁷.
2. Выполняются унарные минусы (отрицания).
3. Выполняются умножения и деления слева направо. Операции умножения и деления имеют одинаковый приоритет.
4. Выполняются сложения и вычитания слева направо. Операции сложения и вычитания имеют одинаковый приоритет.


Основные операции над строками:

- `A+B` — конкатенация;
- `A*n` — повторение ``n`` раз, значение ``n`` должно быть целого типа.

### Упражнение 1. Возведение в степень.

Вычислите $2^{179}$.


```python

```

### Упражнение 2. Гипотенуза.

Вычислите длину гипотенузы в прямоугольном треугольнике со сторонами 179 и 971.


```python

```

### Преобразование типов.

Иногда бывает полезно целое число записать, как строку. И, наоборот, если строка состоит из цифр, то полезно эту строку
представить в виде числа, чтобы дальше можно было выполнять арифметические операции с ним. Для этого используются
функции, одноименные с типом, то есть `int`, `float`,  `str`. Например, `int('123')` вернет целое число `123`, а
`str(123)` вернет строку `'123'`.

Пример:

``` pycon

   >>> str(2 + 2) * int('2' + '2')
   '4444444444444444444444'
```
Результатом будет строка из числа ``4``, повторенная ``22`` раза.

# Простейшие программы

В предыдущем задании мы использовали Python для простых разовых вычислений, используя интерактивный режим. Например,
было задание вычислить длину гипотенузы прямоугольного треугольника по её катетам. Решение этой задачи можно записать
следующим образом:


```python
a = 179
b = 197
c = (a ** 2 + b ** 2) ** 0.5
print(c)
```

Здесь мы используем  **переменные** — объекты, в которых можно сохранять различные (числовые, строковые и прочие)
значения. В первой строке переменной `a` присваивается значение `179`, затем переменной `b` присваивается значение
`971`, затем переменной `c` присваивается значение арифметического выражения, равного длине гипотенузы. После этого
значение переменной `c` выводится на экран.

Сохраните этот текст в файле с именем `hypot.py`. Запустите терминал, перейдите в каталог, где лежит этот файл и
выполните эту программу:

``` bash

   python3 hypot.py
```

Интерпретатор языка Python, запущенный с указанием имени файла, запускается не в интерактивном режиме, а выполняет ту
последовательность команд, которая сохранена в файле. При этом значения вычисленных выражений не выводятся на экран (в
отличии от интерактивного режима), поэтому для того, чтобы вывести результат работы программы, то есть значение
переменной `c`, нам понадобится специальная функция `print`.

### Ввод данных: функция `input`

Пример выше неудобен тем, что исходные данные для программы заданы в тексте программы, и для того, чтобы использовать
программу для другого треугольника необходимо исправлять текст программы. Это неудобно, лучше, чтобы текст программы не
менялся, а программа запрашивала бы у пользователя данные, необходимые для решения задачи, то есть запрашивала бы
значения двух исходных переменных `a` и `b`. Для этого будем использовать функцию `input()`, которая считывает строку с
клавиатуры и возвращает значение считанной строки, которое сразу же присвоим переменным `a` и `b`:


```python
a = input()
b = input()
```

Правда, функция `input` возвращает текстовую строку, а нам нужно сделать так, чтобы переменные имели целочисленные
значения. Поэтому сразу же после считывания выполним преобразование типов при помощи функции `int` и запишем новые
значения в переменные `a` и `b`.


```python
a = int(a)
b = int(b)
```

Можно объединить считывание строк и преобразование типов, если вызывать функцию `int` для того значения, которое вернёт
функция `input`:


```python
a = int(input())
b = int(input())
```

Далее в программе вычислим значение переменной `c` и выведем результат на экран.

Теперь мы можем, не меняя исходного кода программы, многократно использовать её для решения различных задач. Для того
нужно запустить программу и после запуска программы ввести с клавиатуры два числа, нажимая после каждого числа клавишу
`Enter`. Затем программа сама выведет результат.

### Вывод данных: функция `print()`

Функция `print` может выводить не только значения переменных, но и значения любых выражений. Например, допустима запись
`print(2 + 2 ** 2)`. Также при помощи функции `print` можно выводить значение не одного, а нескольких выражений, для
этого нужно перечислить их через запятую:


```python
a = 1
b = 2
print(a, '+', b, '=', a + b)
```

В данном случае будет напечатан текст `1 + 2 = 3`: сначала выводится значение переменной `a`, затем строка из знака `+`,
затем  значение переменной `b`, затем строка из знака `=`, наконец, значение суммы `a + b`.

Обратите внимание, выводимые значения разделяются одним пробелом. Но такое поведение можно изменить: можно разделять
выводимые значения двумя пробелами, любым другим символом, любой другой строкой, выводить их в отдельных строках или не
разделять никак. Для этого нужно функции `print` передать специальный именованный параметр, называемый `sep`, равный
строке, используемый в качестве разделителя (sep —  сокращение слова separator, т.е. разделитель). По умолчанию
параметр `sep` равен строке из одного пробела и между значениями выводится пробел. Чтобы использовать в качестве
разделителя, например, символ двоеточия нужно передать параметр `sep`, равный строке `':'`:


```python
print(a, b, c, sep = ':')
```

Аналогично, для того, чтобы совсем убрать разделитель при выводе нужно передать параметр `sep`, равный пустой строке:


```python
print(a, '+', b, '=', a + b, sep = '')
```

Для того, чтобы значения выводились с новой строки, нужно в качестве параметра `sep` передать строку, состоящую из
специального символа новой строки, которая задаётся так:


```python
print(a, b, sep = '\n')
```

Символ обратного слэша в текстовых строках является указанием на обозначение специального символа, в зависимости
от того, какой символ записан после него. Наиболее часто употребляется символ новой строки `'\n'`.
А для того, чтобы вставить в строку сам символ обратного слэша, нужно повторить его два раза: `'\\'`.

Вторым полезным именованным параметром функции `print` является параметр `end`,
который указывает на то, что выводится после вывода всех значений, перечисленных в функции `print`.
По умолчанию параметр `end` равен `'\n'`, то есть следующий вывод будет происходить
с новой строки. Этот параметр также можно исправить, например, для того, чтобы убрать все дополнительные
выводимые символы можно вызывать функцию `print` так:


```python
print(a, b, c, sep = '', end = '')
```

### Упражнение 3. Гипотенуза с пользовательским вводом.

Считайте с клавиатуры числа `a` и `b`. Выведите гипотенузу треугольника с заданными катетами.


```python

```

# Условная инструкция

Все ранее рассматриваемые программы имели линейную структуру: все инструкции выполнялись последовательно одна за одной, каждая записанная инструкция обязательно выполняется.

Допустим мы хотим по данному числу `x` **определить** его абсолютную величину (**модуль**). Программа должна напечатать значение переменной $x$, если $x > 0$ или же величину $-x$ в противном случае. Линейная структура программы нарушается: в зависимости от справедливости условия $x > 0$ должна быть выведена одна или другая величина. Соответствующий фрагмент программы на Питоне имеет вид:


```python
x = int(input())
if x > 0:
    print(x)
else:
    print(-x)
```

На самом деле, в общем случае условная инструкция является каскадной: `if, elif, elif, ... elif, else`, где `elif` происходит от выражения `else if` (иначе если), она может выполнятся только если ни одно из предыдущих условий не является верным. Например, определение положения точки по координатам:


```python
x = int(input())
y = int(input())
if x > 0 and y > 0:
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")
```

# Функции и методы

Функции нужны для повышения читаемости кода. Если у нас есть некоторые данные `X`, на основании которых в результате последовательности действий должны получиться данные `Y` и результат однозначно определяется начальными данными `X`, то последовательность действий является функцией с точки зрения математики.

Если мы хотим выполнять эту последовательность действий более одного раза (например, с разными данными), то обернуть эту последовательность действий в объект "функция" логично уже с точки зрения программирования, т.к. это сокращает код и делает его более читаемым.

Например, мы хотим уметь считать значение квадратичной функции в разных точках. Рассмотрим код без использования функции и с ее использованием.


```python
a = 1
b = 2
c = 3
d = 4
print(2 * a ** 2 + 3 * a + 5)
print(2 * b ** 2 + 3 * b + 5)
print(2 * c ** 2 + 3 * c + 5)
print(2 * d ** 2 + 3 * d + 5)
```


```python
def f(x):
    return 2 * x ** 2 + 3 * x + 5
print(f(a), f(b), f(c), f(d))
```

Еще пример про гипотенузу:


```python
def f(a, b):
    return (a ** 2 + b ** 2) ** 0.5
print(f(3, 4), f(5, 12))
```

Примеры стандартных функций и методов (уже реализованных за вас в языке Python) для строк и списков вы увидите ниже. Метод – это тоже функция, но реализованная уже для объекта конкретного класса (для строк и списков конкретный класс – то же самое, что конкретный тип). Отличие скорее синтаксическое, чем смысловое (смысловое станет понятно позже и пока нас не интересует).
Функция: `f(x, x1, x2)`, метод: `x.f(x1, x2)`

В отличие от функции, метод явно требует, чтобы `x` был конкретного типа.

## Цикл for. Списки и строки.

Для итерации по множеству значений используется цикл for:


```python
for i in 1, 2, 3, 4:
    print(i)
```

Множество значений может быть задано списком, кортежем, строкой или диапазоном (`range`). На примере ниже мы создаем список `a`, заполненный числами от `1` до `4` и итерируемся по нему:


```python
a = [1, 2, 3, 4]
for x in a:
    print(x)
```

Для обращения к конкретному элементу списка используются индексы:


```python
print(a[1], a[0], a[-1])
```

Мы получили такой результат, потому что **индексация начинается с нуля**. Кроме того, для удобства в Python реализована возможность обращаться к последнему элементу по индексу `-1`, к предпоследнему `-2` и так далее. Для списка из `n` элементов определены индексы от `-n` до `n-1` включительно.

Еще один тип данных, для работы с переменными которого удобна итерация - это строки (`str`). Строка считывается со стандартного ввода функцией `input()`. Напомним, что для двух строк определена операция сложения (конкатенации), также определена операция умножения строки на число.

Строка состоит из последовательности символов. Узнать количество символов (длину строки) можно при помощи функции `len`:


```python
s = "abcd"
s1 = input()
print(len(s), len(s1))
```

Все сказанное про итерацию по спискам справедливо и для строки:


```python
s = "abcdef"
for x in s:
    print(x)
```


```python
print(s[1], s[0], s[-1])
```


```python
print(s[-6])
```

Ошибка `IndexError`
возникает, когда индекс "вылетает" за допустимые пределы либо в положительную, либо в отрицательную сторону:


```python
print(s[-7])
```

Для того чтобы вывести через пробел элементы объекта, по которому мы можем итерироваться, достаточно написать:

$*$ - это разворачивание элементов итерируемого объекта в параметры функции. Соответственно, функция `print` на примере ниже получает несколько аргументов, соответственно, выводит их через пробел


```python
print(*a) 
```


```python
print(*s)
```

### Объект range
Для прохода по индексам удобно использовать генератор арифметических прогрессий `range(start, stop, step)`. У него три параметра:
1. `start` - начальный член,
2. `stop` - ограничитель (значение не включается в прогрессию!),
3. `step` - шаг прогрессии (может быть отрицательным)

И, конечно же, по нему тоже удобно итерироваться.

Примеры:


```python
print(*range(1, 5, 1))
```


```python
print(*range(9, 1, -2))
```

`range` – это функция, которая принимает три параметра. Но не все из них являются обязательными. Например, выше, при выводе `range(1, 5, 1)`, мы увидели `range(1, 5)`. `step=1` это дефолтное значение параметра, поэтому нет разницы, писать `range(1, 5)` или `range(1, 5, 1)`. Кроме того, есть дефолтное значение параметра `start=0`, поэтому если мы хотим получить арифметическую прогрессию, начинающуюся с нуля и с шагом `1` достаточно написать `range(n)` вместо `range(0, n, 1)`:


```python
print(*range(10))
```


```python
print(*range(1, 10))
```


```python
print(*range(10, 1, 1))
```

Почему получился именно такой результат?

Арифметическая прогрессия, которую реализует `range`, сама по себе используется не так часто. Основное удобство `range` состоит в том, что если раньше мы могли итерироваться по элементам списка/строки или обращаться к отдельным элементам списка/строки, то теперь мы можем создать `range` их индексов и кроме прочего **итерироваться** уже **по индексам элеменов списка/строки**:


```python
for i in range(4):
    print(a[i])
```


```python
for i in range(6):
    print(s[i])
```

Есть полезная функция `len`, которая позволяет определить **количество элементов** списка, строки и других объектов:


```python
print(len(a), len(s))
```


```python
for i in range(len(a)):
    print(a[i])
```


```python
for i in range(2, len(s)-1):
    print(s[i])
```

Еще мы можем использовать range(n) для выполнения одной инструкции n раз:


```python
for i in range(5):
    print("!")
```

#### Пример. Дана строка, содержащая только символы 'a', 'b' и 'c'. Удалить из нее все элементы 'b':


```python
s = input()
s1 = ""
for x in s:
    if x != "b":
        s1 = s1 + x
print(s1)
```

#### Пример. Дана символьная строка, содержащая больше 5 символов. Требуется удалить символы с третьего по пятый:


```python
s = input()
s1 = ""
for i in range(2):
    s1 = s1 + s[i] 
for i in range(5, len(s)):
    s1 = s1 + s[i]
print(s1)

```

Для добавления элементов в список используется метод `append` (без присваивания!):


```python
a = [1, 2, 3, 4]
a.append(10)
print(a)
```

Для преобразования строки, полученной вводом через `input()` используется следующая конструкция, детали которой подробнее мы обсудим ниже:


```python
a = [int(i) for i in input().split()]
print(a)
```

#### Пример. Дан список, содержащий больше пяти элементов. Требуется удалить из него все элементы с третьего по пятый.


```python
a = [int(i) for i in input().split()]
b = []
for i in range(2):
    b.append(a[i])
for i in range(5, len(a)):
    b.append(a[i])
print(b)
```

### Задача 1 Считать список. Удалить из него все элементы, равные единице. Вывести элементы полученного списка через пробел.


```python

```

Хотелось бы иметь возможность делать такие преобразования проще. Для этого в Python есть срезы. **Срез (slice)** — извлечение из данной строки одного символа или некоторого фрагмента подстроки или подпоследовательности. Синтаксис среза напоминает синтаксис `range`: 
`s[start:stop:step]` - срез элементов строки/списка с индексами `[start; stop)` с шагом step.

Посмотрим, как упростится решение задачи про удаление символов с третьего по пятый:


```python
s = "abcdefghij"
s1 = s[0:2:1] + s[5:len(s):1]
print(s1)
```

Шаг указывать не обязательно, более того, не обязательно указывать начало, если начинаем с нулевого элемента и конец, если заканчиваем последним:


```python
print(s[:2] + s[5:])
```


```python
print(s[5:0:-2])
```


```python
print(s[4:0:-2])
```


```python
print(s[4:-1:-2])
```

Как интерпретировать этот результат? `-1` - это индекс последнего элемента строки. При отрицательном шаге у нас получается пустая последовательность, т.к. 4-й элемент стоит левее последнего. Для получения того, что мы ожидаем получить, можно просто не указывать значение параметра stop:


```python
print(s[4::-2])
```


```python
print(s[::-1])
```

## Методы строк

Один из основных методов строк - `split`. Это способ разбить строку на список строк по некоторому разделителю. Синтаксис: `str.split(sep)`, sep (от слова separator) - разделитель. По умолчанию `sep=' '`.


```python
s = "1+2+3+4"
print(s.split('+'))
```


```python
s = "1 2 3 4"
print(s.split())
```


```python
s = "www.mipt.ru"
print(s.split("."))
print(s.split(".")[1])
```

Обратный к нему метод - `join`.


```python
a = [1, 2, 3, 4, 5]
print(" ".join(a))
```


```python
a = [1, 2, 3, 4, 5]
for i in range(len(a)):
    a[i] = str(a[i])
print(a)
print(", ".join(a))
```

Для замены фрагмента используется метод `replace`.


```python
s = "abrakadabra"
print(s.replace("a", "A"))
```

Также этот метод можно использовать для удаления частей строки:


```python
s = "abcbcdcba"
s1 = s.replace("b", "")
print(s1)
```

#### Пример.
Рассмотрим задачу подсчета количества вхождений символа `'b'` в строку. Ее можно решить следующим образом:


```python
s = "abcbdbegh"
k = 0
for x in s:
    if x == "b":
        k += 1
print(k)
```

И, конечно, для этого тоже есть готовый метод `count`:


```python
s = "abcbdbegh"
print(s.count("b"))
```


```python
s = "abcbdbegh"
print(s.count("f"))
```

Существуют также методы для поиска первого и последнего вхождения подстроки в строку, перевода букв из верхнего регистра в нижний и обратно и многого другого. Их вы можете найти в интернете при самостоятельной работе над контестом.

Кроме того, есть различные методы списков. Например, append, который мы обсудили выше - это один из методов. Есть метод `count`, аналогичный методу `count` строк и многие другие методы, которые вы также можете найти в интернете. Срезы списков тоже используются аналогично:


```python
a = [1, 2, 3, 4, 3, 2, 5]
print(a.count(3))
```


```python
a = [10, 11, 12, 13, 14, 15, 16]
print(a[2:4])
```

Почему это так?


```python
print(a[::-1])
```


```python
print(a[6::-2])
```

## Заполнение списков; генераторы

Еще раз напомним, как можно заполнять списки с помощью добавления элементов:


```python
a = []
a.append(5)
print(a)
```


```python
a.append(10)
print(a)
```


```python
a = []
for x in range(2, 10, 2):
    a.append(x)
print(a)
```


```python
print(a[2])
```

Очевидно, это не самый удобный способ, и хочется найти что-то проще. Решение - генераторы списков.


```python
a = [x for x in range(2, 10, 2)]
print(a)
```


```python
a = [2 * x for x in range(2, 10, 2)]
print(a)
```

#### Пример. Заполните массив квадратами однозначных чисел


```python
a = [i ** 2 for i in range(10)]
print(a)
```

#### P.S считывание с клавиатуры чисел, введенных через пробел

Делается это вот так:


```python
a, b = map(int, input().split())
```

`map` применяет функцию `int` к элементам списка, полученного из строки `input()` методом `split()`. Результат ложится в переменные `a` и `b`. Другие примеры присваивания в несколько переменных для лучшего понимания приведены ниже. Функцию `map` мы подробнее обсудим на следующих занятиях.


```python
a, b = [1, 2]
print(a)
print(b)
```


```python
a, b = [1, 2], [3, 4]
print(a)
print(b)
```


```python
a, b = [1, 2, 3, 4] # вызовет ошибку
print(a)
print(b)
```


```python
a, b = "ab"
print(a)
print(b)
```


```python
a, b = "abc def".split()
print(a)
print(b)
```
